// Граф — это множество вершин некоторые из которых могут быть соединены рёбрами.
// Односвязный, двусвязный список, деревья - это все графы
// На ребрах можно указывать направление или цифры
// Множество всех вершин графа обозначают V, а множество всех рёбер — E
// ∣V∣ — число вершин,
// ∣E∣ — число рёбер.
// e=(u,v) — Ребро e описывается парой вершин u и v (порядок важен)
// e={u,v} - порядок не важен
// Вершины v и w называют «смежными» если между ними есть ребро {v,w}.
// Если вершина является одним из концов ребра, то говорят, что эти вершина и ребро «инцидентны»
// «Степень вершины» — это число инцидентных ей рёбер.
// Степень входа вершины — количество входящих в неё рёбер, а степень выхода — количество исходящих.
// Длиной пути называют количество рёбер пути.
// Расстояние между двумя вершинами — длина кратчайшего пути
// Весом пути называется сумма весов всех рёбер в указанном пути.
// Цикл — это путь, в котором начальная и конечная вершины совпадают, а рёбра не повторяются.
// Взвешенный граф — это граф, в котором каждому ребру присвоено числовое значение (вес).
// Невзвешенный граф — это граф, в котором нет весов, связанных с рёбрами.


// Поиск в глубину и ширину осуществяется за  O(n + m)
//где n — количество вершин, m — количество рёбер.

// Функция для создания списка смежности (adjacency list) на основе ребер графа
function getVertexList(edges) {
    // Создаем пустой объект для хранения списка смежности
    const adj = {};

    // Перебираем все ребра в графе
    for (let [start, end] of edges) {
        // Добавляем вершину "end" в список смежности для вершины "start"
        if (adj[start]) {
            adj[start].push(end);
        } else {
            adj[start] = [end];  // Если вершины "start" нет, создаем для неё массив с вершиной "end"
        }

        // Добавляем вершину "start" в список смежности для вершины "end"
        if (adj[end]) {
            adj[end].push(start);
        } else {
            adj[end] = [start];  // Если вершины "end" нет, создаем для неё массив с вершиной "start"
        }
    }

    // Сортируем списки смежности для каждой вершины по убыванию (для обхода в глубину)
    for (const key in adj) {
        adj[key] = adj[key].sort((a, b) => b - a); // Сортируем в убывающем порядке
    }

    // Возвращаем полученный список смежности
    return adj;
}

// Главная функция для поиска в глубину (DFS)
function mainDSF(edgesList, vertexStart, vertex) {

    // Получаем список смежности для графа на основе переданных ребер
    const vertexList = getVertexList(edgesList);

    // Создаем массив color для отслеживания состояний вершин:
    // 'white' - еще не посещена, 'grey' - в процессе посещения, 'black' - посещена
    const color = Array.from({length: Number(vertex)}, () => 'white');

    // Инициализируем стек для обхода графа, начиная с вершины vertexStart
    let stack = [vertexStart];

    // Массив для хранения результатов обхода
    const data = [];

    // Проводим поиск в глубину (DFS)
    while (stack.length > 0) {
        const v = stack.pop();  // Извлекаем вершину из стека

        // Если вершина еще не посещена
        if (color[v - 1] === 'white') {
            color[v - 1] = 'grey';  // Отмечаем вершину как в процессе посещения
            stack.push(v);  // Добавляем вершину обратно в стек, чтобы позже отметить как 'black'
            data.push(v);  // Добавляем вершину в итоговый массив данных

            // Получаем список смежных вершин для текущей вершины
            const currentEdges = vertexList[v] || [];

            // Перебираем все соседние вершины
            for (const edge of currentEdges) {
                // Если соседняя вершина не посещена
                if (color[edge - 1] === 'white') {
                    stack.push(edge);  // Добавляем соседнюю вершину в стек
                }
            }
        }
        // Если вершина в процессе посещения, это значит, что она уже была исследована
        else if (color[v - 1] === 'grey') {
            color[v - 1] = 'black';  // Отмечаем вершину как полностью посещенную
        }
    }

    // Возвращаем массив с порядком обхода вершин
    return data;
}

function getVertexList(edges) {
    // Создаем пустой объект для хранения списка смежности
    const adj = {};

    // Перебираем все ребра в графе
    for (let [start, end] of edges) {
        // Добавляем вершину "end" в список смежности для вершины "start"
        if (adj[start]) {
            adj[start].push(end);
        } else {
            adj[start] = [end];  // Если вершины "start" нет, создаем для неё массив с вершиной "end"
        }

        // Добавляем вершину "start" в список смежности для вершины "end"
        if (adj[end]) {
            adj[end].push(start);
        } else {
            adj[end] = [start];  // Если вершины "end" нет, создаем для неё массив с вершиной "start"
        }
    }

    // Сортируем списки смежности для каждой вершины по убыванию (для обхода в глубину)
    for (const key in adj) {
        adj[key] = adj[key].sort((a, b) => b - a); // Сортируем в убывающем порядке
    }

    // Возвращаем полученный список смежности
    return adj;
}


// Обход в глубину
function mainBFS(edgesList, vertexStart, vertex) {
    let color = Array.from({length: vertex + 1}, () => 'white');
    let previous = Array.from({length: vertex + 1}, () => null);
    let distance = Array.from({length: vertex + 1}, () => null);

    function bfs(s) {
        // Создадим очередь вершин и положим туда стартовую вершину.
        let planned = [];
        const result = []
        const list = getVertexList(edgesList)
        const outgoingEdges = (v) => {
            return list[v] ?? []
        }
        planned.push(s);
        color[s] = 'gray';
        distance[s] = 0;

        while (planned.length > 0) {
            let u = planned.shift();  // Возьмём вершину из очереди.
            result.push(u)
            for (let v of outgoingEdges(u)) {
                if (color[v] === 'white') {
                    // Серые и чёрные вершины уже
                    // либо в очереди, либо обработаны.
                    distance[v] = distance[u] + 1;
                    previous[v] = u;
                    color[v] = 'gray';
                    planned.push(v);  // Запланируем посещение вершины.
                }
            }
            color[u] = 'black';  // Теперь вершина считается обработанной.
        }

        return result;
    }

    return bfs(vertexStart)
}
